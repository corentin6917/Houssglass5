// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_profile.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

UserProfile _$UserProfileFromJson(Map<String, dynamic> json) {
  return _UserProfile.fromJson(json);
}

/// @nodoc
mixin _$UserProfile {
  String get id => throw _privateConstructorUsedError;
  String get email => throw _privateConstructorUsedError;
  String get displayName => throw _privateConstructorUsedError;
  String? get avatarUrl => throw _privateConstructorUsedError;
  String get timezone => throw _privateConstructorUsedError;
  double get ratio => throw _privateConstructorUsedError;
  double get totalGrains => throw _privateConstructorUsedError;
  int get daysOnApp => throw _privateConstructorUsedError;
  bool get privacyHideFromFeed => throw _privateConstructorUsedError;
  bool get privacyAnonymous => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;

  /// Serializes this UserProfile to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of UserProfile
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $UserProfileCopyWith<UserProfile> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserProfileCopyWith<$Res> {
  factory $UserProfileCopyWith(
          UserProfile value, $Res Function(UserProfile) then) =
      _$UserProfileCopyWithImpl<$Res, UserProfile>;
  @useResult
  $Res call(
      {String id,
      String email,
      String displayName,
      String? avatarUrl,
      String timezone,
      double ratio,
      double totalGrains,
      int daysOnApp,
      bool privacyHideFromFeed,
      bool privacyAnonymous,
      DateTime createdAt});
}

/// @nodoc
class _$UserProfileCopyWithImpl<$Res, $Val extends UserProfile>
    implements $UserProfileCopyWith<$Res> {
  _$UserProfileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UserProfile
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? email = null,
    Object? displayName = null,
    Object? avatarUrl = freezed,
    Object? timezone = null,
    Object? ratio = null,
    Object? totalGrains = null,
    Object? daysOnApp = null,
    Object? privacyHideFromFeed = null,
    Object? privacyAnonymous = null,
    Object? createdAt = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: null == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      avatarUrl: freezed == avatarUrl
          ? _value.avatarUrl
          : avatarUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      timezone: null == timezone
          ? _value.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as String,
      ratio: null == ratio
          ? _value.ratio
          : ratio // ignore: cast_nullable_to_non_nullable
              as double,
      totalGrains: null == totalGrains
          ? _value.totalGrains
          : totalGrains // ignore: cast_nullable_to_non_nullable
              as double,
      daysOnApp: null == daysOnApp
          ? _value.daysOnApp
          : daysOnApp // ignore: cast_nullable_to_non_nullable
              as int,
      privacyHideFromFeed: null == privacyHideFromFeed
          ? _value.privacyHideFromFeed
          : privacyHideFromFeed // ignore: cast_nullable_to_non_nullable
              as bool,
      privacyAnonymous: null == privacyAnonymous
          ? _value.privacyAnonymous
          : privacyAnonymous // ignore: cast_nullable_to_non_nullable
              as bool,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UserProfileImplCopyWith<$Res>
    implements $UserProfileCopyWith<$Res> {
  factory _$$UserProfileImplCopyWith(
          _$UserProfileImpl value, $Res Function(_$UserProfileImpl) then) =
      __$$UserProfileImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String email,
      String displayName,
      String? avatarUrl,
      String timezone,
      double ratio,
      double totalGrains,
      int daysOnApp,
      bool privacyHideFromFeed,
      bool privacyAnonymous,
      DateTime createdAt});
}

/// @nodoc
class __$$UserProfileImplCopyWithImpl<$Res>
    extends _$UserProfileCopyWithImpl<$Res, _$UserProfileImpl>
    implements _$$UserProfileImplCopyWith<$Res> {
  __$$UserProfileImplCopyWithImpl(
      _$UserProfileImpl _value, $Res Function(_$UserProfileImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserProfile
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? email = null,
    Object? displayName = null,
    Object? avatarUrl = freezed,
    Object? timezone = null,
    Object? ratio = null,
    Object? totalGrains = null,
    Object? daysOnApp = null,
    Object? privacyHideFromFeed = null,
    Object? privacyAnonymous = null,
    Object? createdAt = null,
  }) {
    return _then(_$UserProfileImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: null == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String,
      avatarUrl: freezed == avatarUrl
          ? _value.avatarUrl
          : avatarUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      timezone: null == timezone
          ? _value.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as String,
      ratio: null == ratio
          ? _value.ratio
          : ratio // ignore: cast_nullable_to_non_nullable
              as double,
      totalGrains: null == totalGrains
          ? _value.totalGrains
          : totalGrains // ignore: cast_nullable_to_non_nullable
              as double,
      daysOnApp: null == daysOnApp
          ? _value.daysOnApp
          : daysOnApp // ignore: cast_nullable_to_non_nullable
              as int,
      privacyHideFromFeed: null == privacyHideFromFeed
          ? _value.privacyHideFromFeed
          : privacyHideFromFeed // ignore: cast_nullable_to_non_nullable
              as bool,
      privacyAnonymous: null == privacyAnonymous
          ? _value.privacyAnonymous
          : privacyAnonymous // ignore: cast_nullable_to_non_nullable
              as bool,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserProfileImpl implements _UserProfile {
  const _$UserProfileImpl(
      {required this.id,
      required this.email,
      this.displayName = '',
      this.avatarUrl,
      this.timezone = 'Europe/Paris',
      this.ratio = 0.0,
      this.totalGrains = 0.0,
      this.daysOnApp = 0,
      this.privacyHideFromFeed = false,
      this.privacyAnonymous = false,
      required this.createdAt});

  factory _$UserProfileImpl.fromJson(Map<String, dynamic> json) =>
      _$$UserProfileImplFromJson(json);

  @override
  final String id;
  @override
  final String email;
  @override
  @JsonKey()
  final String displayName;
  @override
  final String? avatarUrl;
  @override
  @JsonKey()
  final String timezone;
  @override
  @JsonKey()
  final double ratio;
  @override
  @JsonKey()
  final double totalGrains;
  @override
  @JsonKey()
  final int daysOnApp;
  @override
  @JsonKey()
  final bool privacyHideFromFeed;
  @override
  @JsonKey()
  final bool privacyAnonymous;
  @override
  final DateTime createdAt;

  @override
  String toString() {
    return 'UserProfile(id: $id, email: $email, displayName: $displayName, avatarUrl: $avatarUrl, timezone: $timezone, ratio: $ratio, totalGrains: $totalGrains, daysOnApp: $daysOnApp, privacyHideFromFeed: $privacyHideFromFeed, privacyAnonymous: $privacyAnonymous, createdAt: $createdAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserProfileImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.avatarUrl, avatarUrl) ||
                other.avatarUrl == avatarUrl) &&
            (identical(other.timezone, timezone) ||
                other.timezone == timezone) &&
            (identical(other.ratio, ratio) || other.ratio == ratio) &&
            (identical(other.totalGrains, totalGrains) ||
                other.totalGrains == totalGrains) &&
            (identical(other.daysOnApp, daysOnApp) ||
                other.daysOnApp == daysOnApp) &&
            (identical(other.privacyHideFromFeed, privacyHideFromFeed) ||
                other.privacyHideFromFeed == privacyHideFromFeed) &&
            (identical(other.privacyAnonymous, privacyAnonymous) ||
                other.privacyAnonymous == privacyAnonymous) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      email,
      displayName,
      avatarUrl,
      timezone,
      ratio,
      totalGrains,
      daysOnApp,
      privacyHideFromFeed,
      privacyAnonymous,
      createdAt);

  /// Create a copy of UserProfile
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UserProfileImplCopyWith<_$UserProfileImpl> get copyWith =>
      __$$UserProfileImplCopyWithImpl<_$UserProfileImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UserProfileImplToJson(
      this,
    );
  }
}

abstract class _UserProfile implements UserProfile {
  const factory _UserProfile(
      {required final String id,
      required final String email,
      final String displayName,
      final String? avatarUrl,
      final String timezone,
      final double ratio,
      final double totalGrains,
      final int daysOnApp,
      final bool privacyHideFromFeed,
      final bool privacyAnonymous,
      required final DateTime createdAt}) = _$UserProfileImpl;

  factory _UserProfile.fromJson(Map<String, dynamic> json) =
      _$UserProfileImpl.fromJson;

  @override
  String get id;
  @override
  String get email;
  @override
  String get displayName;
  @override
  String? get avatarUrl;
  @override
  String get timezone;
  @override
  double get ratio;
  @override
  double get totalGrains;
  @override
  int get daysOnApp;
  @override
  bool get privacyHideFromFeed;
  @override
  bool get privacyAnonymous;
  @override
  DateTime get createdAt;

  /// Create a copy of UserProfile
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UserProfileImplCopyWith<_$UserProfileImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DailyContract _$DailyContractFromJson(Map<String, dynamic> json) {
  return _DailyContract.fromJson(json);
}

/// @nodoc
mixin _$DailyContract {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  DateTime get date => throw _privateConstructorUsedError;
  String get status => throw _privateConstructorUsedError; // open, synced
  DateTime get createdAt => throw _privateConstructorUsedError;

  /// Serializes this DailyContract to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DailyContract
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DailyContractCopyWith<DailyContract> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DailyContractCopyWith<$Res> {
  factory $DailyContractCopyWith(
          DailyContract value, $Res Function(DailyContract) then) =
      _$DailyContractCopyWithImpl<$Res, DailyContract>;
  @useResult
  $Res call(
      {String id,
      String userId,
      DateTime date,
      String status,
      DateTime createdAt});
}

/// @nodoc
class _$DailyContractCopyWithImpl<$Res, $Val extends DailyContract>
    implements $DailyContractCopyWith<$Res> {
  _$DailyContractCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DailyContract
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? date = null,
    Object? status = null,
    Object? createdAt = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DailyContractImplCopyWith<$Res>
    implements $DailyContractCopyWith<$Res> {
  factory _$$DailyContractImplCopyWith(
          _$DailyContractImpl value, $Res Function(_$DailyContractImpl) then) =
      __$$DailyContractImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      DateTime date,
      String status,
      DateTime createdAt});
}

/// @nodoc
class __$$DailyContractImplCopyWithImpl<$Res>
    extends _$DailyContractCopyWithImpl<$Res, _$DailyContractImpl>
    implements _$$DailyContractImplCopyWith<$Res> {
  __$$DailyContractImplCopyWithImpl(
      _$DailyContractImpl _value, $Res Function(_$DailyContractImpl) _then)
      : super(_value, _then);

  /// Create a copy of DailyContract
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? date = null,
    Object? status = null,
    Object? createdAt = null,
  }) {
    return _then(_$DailyContractImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      date: null == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DailyContractImpl implements _DailyContract {
  const _$DailyContractImpl(
      {required this.id,
      required this.userId,
      required this.date,
      this.status = 'open',
      required this.createdAt});

  factory _$DailyContractImpl.fromJson(Map<String, dynamic> json) =>
      _$$DailyContractImplFromJson(json);

  @override
  final String id;
  @override
  final String userId;
  @override
  final DateTime date;
  @override
  @JsonKey()
  final String status;
// open, synced
  @override
  final DateTime createdAt;

  @override
  String toString() {
    return 'DailyContract(id: $id, userId: $userId, date: $date, status: $status, createdAt: $createdAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DailyContractImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, userId, date, status, createdAt);

  /// Create a copy of DailyContract
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DailyContractImplCopyWith<_$DailyContractImpl> get copyWith =>
      __$$DailyContractImplCopyWithImpl<_$DailyContractImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DailyContractImplToJson(
      this,
    );
  }
}

abstract class _DailyContract implements DailyContract {
  const factory _DailyContract(
      {required final String id,
      required final String userId,
      required final DateTime date,
      final String status,
      required final DateTime createdAt}) = _$DailyContractImpl;

  factory _DailyContract.fromJson(Map<String, dynamic> json) =
      _$DailyContractImpl.fromJson;

  @override
  String get id;
  @override
  String get userId;
  @override
  DateTime get date;
  @override
  String get status; // open, synced
  @override
  DateTime get createdAt;

  /// Create a copy of DailyContract
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DailyContractImplCopyWith<_$DailyContractImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Goal _$GoalFromJson(Map<String, dynamic> json) {
  return _Goal.fromJson(json);
}

/// @nodoc
mixin _$Goal {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  double get baseValue => throw _privateConstructorUsedError;
  DateTime? get lastUsedAt => throw _privateConstructorUsedError;
  int get repeatCount => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;

  /// Serializes this Goal to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Goal
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GoalCopyWith<Goal> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GoalCopyWith<$Res> {
  factory $GoalCopyWith(Goal value, $Res Function(Goal) then) =
      _$GoalCopyWithImpl<$Res, Goal>;
  @useResult
  $Res call(
      {String id,
      String userId,
      String title,
      double baseValue,
      DateTime? lastUsedAt,
      int repeatCount,
      DateTime createdAt});
}

/// @nodoc
class _$GoalCopyWithImpl<$Res, $Val extends Goal>
    implements $GoalCopyWith<$Res> {
  _$GoalCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Goal
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? title = null,
    Object? baseValue = null,
    Object? lastUsedAt = freezed,
    Object? repeatCount = null,
    Object? createdAt = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      baseValue: null == baseValue
          ? _value.baseValue
          : baseValue // ignore: cast_nullable_to_non_nullable
              as double,
      lastUsedAt: freezed == lastUsedAt
          ? _value.lastUsedAt
          : lastUsedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      repeatCount: null == repeatCount
          ? _value.repeatCount
          : repeatCount // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GoalImplCopyWith<$Res> implements $GoalCopyWith<$Res> {
  factory _$$GoalImplCopyWith(
          _$GoalImpl value, $Res Function(_$GoalImpl) then) =
      __$$GoalImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      String title,
      double baseValue,
      DateTime? lastUsedAt,
      int repeatCount,
      DateTime createdAt});
}

/// @nodoc
class __$$GoalImplCopyWithImpl<$Res>
    extends _$GoalCopyWithImpl<$Res, _$GoalImpl>
    implements _$$GoalImplCopyWith<$Res> {
  __$$GoalImplCopyWithImpl(_$GoalImpl _value, $Res Function(_$GoalImpl) _then)
      : super(_value, _then);

  /// Create a copy of Goal
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? title = null,
    Object? baseValue = null,
    Object? lastUsedAt = freezed,
    Object? repeatCount = null,
    Object? createdAt = null,
  }) {
    return _then(_$GoalImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      baseValue: null == baseValue
          ? _value.baseValue
          : baseValue // ignore: cast_nullable_to_non_nullable
              as double,
      lastUsedAt: freezed == lastUsedAt
          ? _value.lastUsedAt
          : lastUsedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      repeatCount: null == repeatCount
          ? _value.repeatCount
          : repeatCount // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GoalImpl implements _Goal {
  const _$GoalImpl(
      {required this.id,
      required this.userId,
      required this.title,
      this.baseValue = 1.0,
      this.lastUsedAt,
      this.repeatCount = 0,
      required this.createdAt});

  factory _$GoalImpl.fromJson(Map<String, dynamic> json) =>
      _$$GoalImplFromJson(json);

  @override
  final String id;
  @override
  final String userId;
  @override
  final String title;
  @override
  @JsonKey()
  final double baseValue;
  @override
  final DateTime? lastUsedAt;
  @override
  @JsonKey()
  final int repeatCount;
  @override
  final DateTime createdAt;

  @override
  String toString() {
    return 'Goal(id: $id, userId: $userId, title: $title, baseValue: $baseValue, lastUsedAt: $lastUsedAt, repeatCount: $repeatCount, createdAt: $createdAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GoalImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.baseValue, baseValue) ||
                other.baseValue == baseValue) &&
            (identical(other.lastUsedAt, lastUsedAt) ||
                other.lastUsedAt == lastUsedAt) &&
            (identical(other.repeatCount, repeatCount) ||
                other.repeatCount == repeatCount) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, userId, title, baseValue,
      lastUsedAt, repeatCount, createdAt);

  /// Create a copy of Goal
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GoalImplCopyWith<_$GoalImpl> get copyWith =>
      __$$GoalImplCopyWithImpl<_$GoalImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GoalImplToJson(
      this,
    );
  }
}

abstract class _Goal implements Goal {
  const factory _Goal(
      {required final String id,
      required final String userId,
      required final String title,
      final double baseValue,
      final DateTime? lastUsedAt,
      final int repeatCount,
      required final DateTime createdAt}) = _$GoalImpl;

  factory _Goal.fromJson(Map<String, dynamic> json) = _$GoalImpl.fromJson;

  @override
  String get id;
  @override
  String get userId;
  @override
  String get title;
  @override
  double get baseValue;
  @override
  DateTime? get lastUsedAt;
  @override
  int get repeatCount;
  @override
  DateTime get createdAt;

  /// Create a copy of Goal
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GoalImplCopyWith<_$GoalImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DailyGoal _$DailyGoalFromJson(Map<String, dynamic> json) {
  return _DailyGoal.fromJson(json);
}

/// @nodoc
mixin _$DailyGoal {
  String get id => throw _privateConstructorUsedError;
  String get contractId => throw _privateConstructorUsedError;
  String get goalId => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  double get assignedValue => throw _privateConstructorUsedError;
  int get phase =>
      throw _privateConstructorUsedError; // 1-4 for devaluation phases
  String? get proofUrl => throw _privateConstructorUsedError;
  DateTime? get completedAt => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;

  /// Serializes this DailyGoal to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DailyGoal
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DailyGoalCopyWith<DailyGoal> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DailyGoalCopyWith<$Res> {
  factory $DailyGoalCopyWith(DailyGoal value, $Res Function(DailyGoal) then) =
      _$DailyGoalCopyWithImpl<$Res, DailyGoal>;
  @useResult
  $Res call(
      {String id,
      String contractId,
      String goalId,
      String title,
      double assignedValue,
      int phase,
      String? proofUrl,
      DateTime? completedAt,
      DateTime createdAt});
}

/// @nodoc
class _$DailyGoalCopyWithImpl<$Res, $Val extends DailyGoal>
    implements $DailyGoalCopyWith<$Res> {
  _$DailyGoalCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DailyGoal
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? contractId = null,
    Object? goalId = null,
    Object? title = null,
    Object? assignedValue = null,
    Object? phase = null,
    Object? proofUrl = freezed,
    Object? completedAt = freezed,
    Object? createdAt = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      contractId: null == contractId
          ? _value.contractId
          : contractId // ignore: cast_nullable_to_non_nullable
              as String,
      goalId: null == goalId
          ? _value.goalId
          : goalId // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      assignedValue: null == assignedValue
          ? _value.assignedValue
          : assignedValue // ignore: cast_nullable_to_non_nullable
              as double,
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as int,
      proofUrl: freezed == proofUrl
          ? _value.proofUrl
          : proofUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DailyGoalImplCopyWith<$Res>
    implements $DailyGoalCopyWith<$Res> {
  factory _$$DailyGoalImplCopyWith(
          _$DailyGoalImpl value, $Res Function(_$DailyGoalImpl) then) =
      __$$DailyGoalImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String contractId,
      String goalId,
      String title,
      double assignedValue,
      int phase,
      String? proofUrl,
      DateTime? completedAt,
      DateTime createdAt});
}

/// @nodoc
class __$$DailyGoalImplCopyWithImpl<$Res>
    extends _$DailyGoalCopyWithImpl<$Res, _$DailyGoalImpl>
    implements _$$DailyGoalImplCopyWith<$Res> {
  __$$DailyGoalImplCopyWithImpl(
      _$DailyGoalImpl _value, $Res Function(_$DailyGoalImpl) _then)
      : super(_value, _then);

  /// Create a copy of DailyGoal
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? contractId = null,
    Object? goalId = null,
    Object? title = null,
    Object? assignedValue = null,
    Object? phase = null,
    Object? proofUrl = freezed,
    Object? completedAt = freezed,
    Object? createdAt = null,
  }) {
    return _then(_$DailyGoalImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      contractId: null == contractId
          ? _value.contractId
          : contractId // ignore: cast_nullable_to_non_nullable
              as String,
      goalId: null == goalId
          ? _value.goalId
          : goalId // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      assignedValue: null == assignedValue
          ? _value.assignedValue
          : assignedValue // ignore: cast_nullable_to_non_nullable
              as double,
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as int,
      proofUrl: freezed == proofUrl
          ? _value.proofUrl
          : proofUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DailyGoalImpl implements _DailyGoal {
  const _$DailyGoalImpl(
      {required this.id,
      required this.contractId,
      required this.goalId,
      required this.title,
      required this.assignedValue,
      this.phase = 1,
      this.proofUrl,
      this.completedAt,
      required this.createdAt});

  factory _$DailyGoalImpl.fromJson(Map<String, dynamic> json) =>
      _$$DailyGoalImplFromJson(json);

  @override
  final String id;
  @override
  final String contractId;
  @override
  final String goalId;
  @override
  final String title;
  @override
  final double assignedValue;
  @override
  @JsonKey()
  final int phase;
// 1-4 for devaluation phases
  @override
  final String? proofUrl;
  @override
  final DateTime? completedAt;
  @override
  final DateTime createdAt;

  @override
  String toString() {
    return 'DailyGoal(id: $id, contractId: $contractId, goalId: $goalId, title: $title, assignedValue: $assignedValue, phase: $phase, proofUrl: $proofUrl, completedAt: $completedAt, createdAt: $createdAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DailyGoalImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.contractId, contractId) ||
                other.contractId == contractId) &&
            (identical(other.goalId, goalId) || other.goalId == goalId) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.assignedValue, assignedValue) ||
                other.assignedValue == assignedValue) &&
            (identical(other.phase, phase) || other.phase == phase) &&
            (identical(other.proofUrl, proofUrl) ||
                other.proofUrl == proofUrl) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, contractId, goalId, title,
      assignedValue, phase, proofUrl, completedAt, createdAt);

  /// Create a copy of DailyGoal
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DailyGoalImplCopyWith<_$DailyGoalImpl> get copyWith =>
      __$$DailyGoalImplCopyWithImpl<_$DailyGoalImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DailyGoalImplToJson(
      this,
    );
  }
}

abstract class _DailyGoal implements DailyGoal {
  const factory _DailyGoal(
      {required final String id,
      required final String contractId,
      required final String goalId,
      required final String title,
      required final double assignedValue,
      final int phase,
      final String? proofUrl,
      final DateTime? completedAt,
      required final DateTime createdAt}) = _$DailyGoalImpl;

  factory _DailyGoal.fromJson(Map<String, dynamic> json) =
      _$DailyGoalImpl.fromJson;

  @override
  String get id;
  @override
  String get contractId;
  @override
  String get goalId;
  @override
  String get title;
  @override
  double get assignedValue;
  @override
  int get phase; // 1-4 for devaluation phases
  @override
  String? get proofUrl;
  @override
  DateTime? get completedAt;
  @override
  DateTime get createdAt;

  /// Create a copy of DailyGoal
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DailyGoalImplCopyWith<_$DailyGoalImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

GrainLedger _$GrainLedgerFromJson(Map<String, dynamic> json) {
  return _GrainLedger.fromJson(json);
}

/// @nodoc
mixin _$GrainLedger {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  String get type =>
      throw _privateConstructorUsedError; // earn, evaporate, boost, transfusion_in, transfusion_out, comment_cost
  double get amount => throw _privateConstructorUsedError;
  String? get refId => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;

  /// Serializes this GrainLedger to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of GrainLedger
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GrainLedgerCopyWith<GrainLedger> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GrainLedgerCopyWith<$Res> {
  factory $GrainLedgerCopyWith(
          GrainLedger value, $Res Function(GrainLedger) then) =
      _$GrainLedgerCopyWithImpl<$Res, GrainLedger>;
  @useResult
  $Res call(
      {String id,
      String userId,
      String type,
      double amount,
      String? refId,
      DateTime createdAt});
}

/// @nodoc
class _$GrainLedgerCopyWithImpl<$Res, $Val extends GrainLedger>
    implements $GrainLedgerCopyWith<$Res> {
  _$GrainLedgerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GrainLedger
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? type = null,
    Object? amount = null,
    Object? refId = freezed,
    Object? createdAt = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      refId: freezed == refId
          ? _value.refId
          : refId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GrainLedgerImplCopyWith<$Res>
    implements $GrainLedgerCopyWith<$Res> {
  factory _$$GrainLedgerImplCopyWith(
          _$GrainLedgerImpl value, $Res Function(_$GrainLedgerImpl) then) =
      __$$GrainLedgerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      String type,
      double amount,
      String? refId,
      DateTime createdAt});
}

/// @nodoc
class __$$GrainLedgerImplCopyWithImpl<$Res>
    extends _$GrainLedgerCopyWithImpl<$Res, _$GrainLedgerImpl>
    implements _$$GrainLedgerImplCopyWith<$Res> {
  __$$GrainLedgerImplCopyWithImpl(
      _$GrainLedgerImpl _value, $Res Function(_$GrainLedgerImpl) _then)
      : super(_value, _then);

  /// Create a copy of GrainLedger
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? type = null,
    Object? amount = null,
    Object? refId = freezed,
    Object? createdAt = null,
  }) {
    return _then(_$GrainLedgerImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      refId: freezed == refId
          ? _value.refId
          : refId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GrainLedgerImpl implements _GrainLedger {
  const _$GrainLedgerImpl(
      {required this.id,
      required this.userId,
      required this.type,
      required this.amount,
      this.refId,
      required this.createdAt});

  factory _$GrainLedgerImpl.fromJson(Map<String, dynamic> json) =>
      _$$GrainLedgerImplFromJson(json);

  @override
  final String id;
  @override
  final String userId;
  @override
  final String type;
// earn, evaporate, boost, transfusion_in, transfusion_out, comment_cost
  @override
  final double amount;
  @override
  final String? refId;
  @override
  final DateTime createdAt;

  @override
  String toString() {
    return 'GrainLedger(id: $id, userId: $userId, type: $type, amount: $amount, refId: $refId, createdAt: $createdAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GrainLedgerImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.refId, refId) || other.refId == refId) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, userId, type, amount, refId, createdAt);

  /// Create a copy of GrainLedger
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GrainLedgerImplCopyWith<_$GrainLedgerImpl> get copyWith =>
      __$$GrainLedgerImplCopyWithImpl<_$GrainLedgerImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GrainLedgerImplToJson(
      this,
    );
  }
}

abstract class _GrainLedger implements GrainLedger {
  const factory _GrainLedger(
      {required final String id,
      required final String userId,
      required final String type,
      required final double amount,
      final String? refId,
      required final DateTime createdAt}) = _$GrainLedgerImpl;

  factory _GrainLedger.fromJson(Map<String, dynamic> json) =
      _$GrainLedgerImpl.fromJson;

  @override
  String get id;
  @override
  String get userId;
  @override
  String
      get type; // earn, evaporate, boost, transfusion_in, transfusion_out, comment_cost
  @override
  double get amount;
  @override
  String? get refId;
  @override
  DateTime get createdAt;

  /// Create a copy of GrainLedger
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GrainLedgerImplCopyWith<_$GrainLedgerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FeedItem _$FeedItemFromJson(Map<String, dynamic> json) {
  return _FeedItem.fromJson(json);
}

/// @nodoc
mixin _$FeedItem {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  String get dailyGoalId => throw _privateConstructorUsedError;
  String get goalTitle => throw _privateConstructorUsedError;
  String? get proofUrl => throw _privateConstructorUsedError;
  double? get grainsEarned => throw _privateConstructorUsedError;
  String? get userDisplayName => throw _privateConstructorUsedError;
  String? get userAvatarUrl => throw _privateConstructorUsedError;
  DateTime get visibleFrom => throw _privateConstructorUsedError;
  DateTime get expiresAt => throw _privateConstructorUsedError;
  int get boostsCount => throw _privateConstructorUsedError;
  int get commentsCount => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;

  /// Serializes this FeedItem to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of FeedItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FeedItemCopyWith<FeedItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FeedItemCopyWith<$Res> {
  factory $FeedItemCopyWith(FeedItem value, $Res Function(FeedItem) then) =
      _$FeedItemCopyWithImpl<$Res, FeedItem>;
  @useResult
  $Res call(
      {String id,
      String userId,
      String dailyGoalId,
      String goalTitle,
      String? proofUrl,
      double? grainsEarned,
      String? userDisplayName,
      String? userAvatarUrl,
      DateTime visibleFrom,
      DateTime expiresAt,
      int boostsCount,
      int commentsCount,
      DateTime createdAt});
}

/// @nodoc
class _$FeedItemCopyWithImpl<$Res, $Val extends FeedItem>
    implements $FeedItemCopyWith<$Res> {
  _$FeedItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FeedItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? dailyGoalId = null,
    Object? goalTitle = null,
    Object? proofUrl = freezed,
    Object? grainsEarned = freezed,
    Object? userDisplayName = freezed,
    Object? userAvatarUrl = freezed,
    Object? visibleFrom = null,
    Object? expiresAt = null,
    Object? boostsCount = null,
    Object? commentsCount = null,
    Object? createdAt = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      dailyGoalId: null == dailyGoalId
          ? _value.dailyGoalId
          : dailyGoalId // ignore: cast_nullable_to_non_nullable
              as String,
      goalTitle: null == goalTitle
          ? _value.goalTitle
          : goalTitle // ignore: cast_nullable_to_non_nullable
              as String,
      proofUrl: freezed == proofUrl
          ? _value.proofUrl
          : proofUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      grainsEarned: freezed == grainsEarned
          ? _value.grainsEarned
          : grainsEarned // ignore: cast_nullable_to_non_nullable
              as double?,
      userDisplayName: freezed == userDisplayName
          ? _value.userDisplayName
          : userDisplayName // ignore: cast_nullable_to_non_nullable
              as String?,
      userAvatarUrl: freezed == userAvatarUrl
          ? _value.userAvatarUrl
          : userAvatarUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      visibleFrom: null == visibleFrom
          ? _value.visibleFrom
          : visibleFrom // ignore: cast_nullable_to_non_nullable
              as DateTime,
      expiresAt: null == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      boostsCount: null == boostsCount
          ? _value.boostsCount
          : boostsCount // ignore: cast_nullable_to_non_nullable
              as int,
      commentsCount: null == commentsCount
          ? _value.commentsCount
          : commentsCount // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FeedItemImplCopyWith<$Res>
    implements $FeedItemCopyWith<$Res> {
  factory _$$FeedItemImplCopyWith(
          _$FeedItemImpl value, $Res Function(_$FeedItemImpl) then) =
      __$$FeedItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      String dailyGoalId,
      String goalTitle,
      String? proofUrl,
      double? grainsEarned,
      String? userDisplayName,
      String? userAvatarUrl,
      DateTime visibleFrom,
      DateTime expiresAt,
      int boostsCount,
      int commentsCount,
      DateTime createdAt});
}

/// @nodoc
class __$$FeedItemImplCopyWithImpl<$Res>
    extends _$FeedItemCopyWithImpl<$Res, _$FeedItemImpl>
    implements _$$FeedItemImplCopyWith<$Res> {
  __$$FeedItemImplCopyWithImpl(
      _$FeedItemImpl _value, $Res Function(_$FeedItemImpl) _then)
      : super(_value, _then);

  /// Create a copy of FeedItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? dailyGoalId = null,
    Object? goalTitle = null,
    Object? proofUrl = freezed,
    Object? grainsEarned = freezed,
    Object? userDisplayName = freezed,
    Object? userAvatarUrl = freezed,
    Object? visibleFrom = null,
    Object? expiresAt = null,
    Object? boostsCount = null,
    Object? commentsCount = null,
    Object? createdAt = null,
  }) {
    return _then(_$FeedItemImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      dailyGoalId: null == dailyGoalId
          ? _value.dailyGoalId
          : dailyGoalId // ignore: cast_nullable_to_non_nullable
              as String,
      goalTitle: null == goalTitle
          ? _value.goalTitle
          : goalTitle // ignore: cast_nullable_to_non_nullable
              as String,
      proofUrl: freezed == proofUrl
          ? _value.proofUrl
          : proofUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      grainsEarned: freezed == grainsEarned
          ? _value.grainsEarned
          : grainsEarned // ignore: cast_nullable_to_non_nullable
              as double?,
      userDisplayName: freezed == userDisplayName
          ? _value.userDisplayName
          : userDisplayName // ignore: cast_nullable_to_non_nullable
              as String?,
      userAvatarUrl: freezed == userAvatarUrl
          ? _value.userAvatarUrl
          : userAvatarUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      visibleFrom: null == visibleFrom
          ? _value.visibleFrom
          : visibleFrom // ignore: cast_nullable_to_non_nullable
              as DateTime,
      expiresAt: null == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      boostsCount: null == boostsCount
          ? _value.boostsCount
          : boostsCount // ignore: cast_nullable_to_non_nullable
              as int,
      commentsCount: null == commentsCount
          ? _value.commentsCount
          : commentsCount // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FeedItemImpl implements _FeedItem {
  const _$FeedItemImpl(
      {required this.id,
      required this.userId,
      required this.dailyGoalId,
      required this.goalTitle,
      this.proofUrl,
      this.grainsEarned,
      this.userDisplayName,
      this.userAvatarUrl,
      required this.visibleFrom,
      required this.expiresAt,
      this.boostsCount = 0,
      this.commentsCount = 0,
      required this.createdAt});

  factory _$FeedItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$FeedItemImplFromJson(json);

  @override
  final String id;
  @override
  final String userId;
  @override
  final String dailyGoalId;
  @override
  final String goalTitle;
  @override
  final String? proofUrl;
  @override
  final double? grainsEarned;
  @override
  final String? userDisplayName;
  @override
  final String? userAvatarUrl;
  @override
  final DateTime visibleFrom;
  @override
  final DateTime expiresAt;
  @override
  @JsonKey()
  final int boostsCount;
  @override
  @JsonKey()
  final int commentsCount;
  @override
  final DateTime createdAt;

  @override
  String toString() {
    return 'FeedItem(id: $id, userId: $userId, dailyGoalId: $dailyGoalId, goalTitle: $goalTitle, proofUrl: $proofUrl, grainsEarned: $grainsEarned, userDisplayName: $userDisplayName, userAvatarUrl: $userAvatarUrl, visibleFrom: $visibleFrom, expiresAt: $expiresAt, boostsCount: $boostsCount, commentsCount: $commentsCount, createdAt: $createdAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeedItemImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.dailyGoalId, dailyGoalId) ||
                other.dailyGoalId == dailyGoalId) &&
            (identical(other.goalTitle, goalTitle) ||
                other.goalTitle == goalTitle) &&
            (identical(other.proofUrl, proofUrl) ||
                other.proofUrl == proofUrl) &&
            (identical(other.grainsEarned, grainsEarned) ||
                other.grainsEarned == grainsEarned) &&
            (identical(other.userDisplayName, userDisplayName) ||
                other.userDisplayName == userDisplayName) &&
            (identical(other.userAvatarUrl, userAvatarUrl) ||
                other.userAvatarUrl == userAvatarUrl) &&
            (identical(other.visibleFrom, visibleFrom) ||
                other.visibleFrom == visibleFrom) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.boostsCount, boostsCount) ||
                other.boostsCount == boostsCount) &&
            (identical(other.commentsCount, commentsCount) ||
                other.commentsCount == commentsCount) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      userId,
      dailyGoalId,
      goalTitle,
      proofUrl,
      grainsEarned,
      userDisplayName,
      userAvatarUrl,
      visibleFrom,
      expiresAt,
      boostsCount,
      commentsCount,
      createdAt);

  /// Create a copy of FeedItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FeedItemImplCopyWith<_$FeedItemImpl> get copyWith =>
      __$$FeedItemImplCopyWithImpl<_$FeedItemImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FeedItemImplToJson(
      this,
    );
  }
}

abstract class _FeedItem implements FeedItem {
  const factory _FeedItem(
      {required final String id,
      required final String userId,
      required final String dailyGoalId,
      required final String goalTitle,
      final String? proofUrl,
      final double? grainsEarned,
      final String? userDisplayName,
      final String? userAvatarUrl,
      required final DateTime visibleFrom,
      required final DateTime expiresAt,
      final int boostsCount,
      final int commentsCount,
      required final DateTime createdAt}) = _$FeedItemImpl;

  factory _FeedItem.fromJson(Map<String, dynamic> json) =
      _$FeedItemImpl.fromJson;

  @override
  String get id;
  @override
  String get userId;
  @override
  String get dailyGoalId;
  @override
  String get goalTitle;
  @override
  String? get proofUrl;
  @override
  double? get grainsEarned;
  @override
  String? get userDisplayName;
  @override
  String? get userAvatarUrl;
  @override
  DateTime get visibleFrom;
  @override
  DateTime get expiresAt;
  @override
  int get boostsCount;
  @override
  int get commentsCount;
  @override
  DateTime get createdAt;

  /// Create a copy of FeedItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FeedItemImplCopyWith<_$FeedItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Season _$SeasonFromJson(Map<String, dynamic> json) {
  return _Season.fromJson(json);
}

/// @nodoc
mixin _$Season {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  String get label =>
      throw _privateConstructorUsedError; // winter, spring, summer, autumn
  DateTime get startedAt => throw _privateConstructorUsedError;
  DateTime? get endedAt => throw _privateConstructorUsedError;

  /// Serializes this Season to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Season
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SeasonCopyWith<Season> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SeasonCopyWith<$Res> {
  factory $SeasonCopyWith(Season value, $Res Function(Season) then) =
      _$SeasonCopyWithImpl<$Res, Season>;
  @useResult
  $Res call(
      {String id,
      String userId,
      String label,
      DateTime startedAt,
      DateTime? endedAt});
}

/// @nodoc
class _$SeasonCopyWithImpl<$Res, $Val extends Season>
    implements $SeasonCopyWith<$Res> {
  _$SeasonCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Season
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? label = null,
    Object? startedAt = null,
    Object? endedAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      label: null == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String,
      startedAt: null == startedAt
          ? _value.startedAt
          : startedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      endedAt: freezed == endedAt
          ? _value.endedAt
          : endedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SeasonImplCopyWith<$Res> implements $SeasonCopyWith<$Res> {
  factory _$$SeasonImplCopyWith(
          _$SeasonImpl value, $Res Function(_$SeasonImpl) then) =
      __$$SeasonImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      String label,
      DateTime startedAt,
      DateTime? endedAt});
}

/// @nodoc
class __$$SeasonImplCopyWithImpl<$Res>
    extends _$SeasonCopyWithImpl<$Res, _$SeasonImpl>
    implements _$$SeasonImplCopyWith<$Res> {
  __$$SeasonImplCopyWithImpl(
      _$SeasonImpl _value, $Res Function(_$SeasonImpl) _then)
      : super(_value, _then);

  /// Create a copy of Season
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? label = null,
    Object? startedAt = null,
    Object? endedAt = freezed,
  }) {
    return _then(_$SeasonImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      label: null == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String,
      startedAt: null == startedAt
          ? _value.startedAt
          : startedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      endedAt: freezed == endedAt
          ? _value.endedAt
          : endedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SeasonImpl implements _Season {
  const _$SeasonImpl(
      {required this.id,
      required this.userId,
      required this.label,
      required this.startedAt,
      this.endedAt});

  factory _$SeasonImpl.fromJson(Map<String, dynamic> json) =>
      _$$SeasonImplFromJson(json);

  @override
  final String id;
  @override
  final String userId;
  @override
  final String label;
// winter, spring, summer, autumn
  @override
  final DateTime startedAt;
  @override
  final DateTime? endedAt;

  @override
  String toString() {
    return 'Season(id: $id, userId: $userId, label: $label, startedAt: $startedAt, endedAt: $endedAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SeasonImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.label, label) || other.label == label) &&
            (identical(other.startedAt, startedAt) ||
                other.startedAt == startedAt) &&
            (identical(other.endedAt, endedAt) || other.endedAt == endedAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, userId, label, startedAt, endedAt);

  /// Create a copy of Season
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SeasonImplCopyWith<_$SeasonImpl> get copyWith =>
      __$$SeasonImplCopyWithImpl<_$SeasonImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SeasonImplToJson(
      this,
    );
  }
}

abstract class _Season implements Season {
  const factory _Season(
      {required final String id,
      required final String userId,
      required final String label,
      required final DateTime startedAt,
      final DateTime? endedAt}) = _$SeasonImpl;

  factory _Season.fromJson(Map<String, dynamic> json) = _$SeasonImpl.fromJson;

  @override
  String get id;
  @override
  String get userId;
  @override
  String get label; // winter, spring, summer, autumn
  @override
  DateTime get startedAt;
  @override
  DateTime? get endedAt;

  /// Create a copy of Season
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SeasonImplCopyWith<_$SeasonImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PhoenixState _$PhoenixStateFromJson(Map<String, dynamic> json) {
  return _PhoenixState.fromJson(json);
}

/// @nodoc
mixin _$PhoenixState {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  bool get active => throw _privateConstructorUsedError;
  DateTime get startedAt => throw _privateConstructorUsedError;
  DateTime? get endedAt => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metricsSnapshot =>
      throw _privateConstructorUsedError;

  /// Serializes this PhoenixState to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PhoenixState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PhoenixStateCopyWith<PhoenixState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PhoenixStateCopyWith<$Res> {
  factory $PhoenixStateCopyWith(
          PhoenixState value, $Res Function(PhoenixState) then) =
      _$PhoenixStateCopyWithImpl<$Res, PhoenixState>;
  @useResult
  $Res call(
      {String id,
      String userId,
      bool active,
      DateTime startedAt,
      DateTime? endedAt,
      Map<String, dynamic>? metricsSnapshot});
}

/// @nodoc
class _$PhoenixStateCopyWithImpl<$Res, $Val extends PhoenixState>
    implements $PhoenixStateCopyWith<$Res> {
  _$PhoenixStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PhoenixState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? active = null,
    Object? startedAt = null,
    Object? endedAt = freezed,
    Object? metricsSnapshot = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      startedAt: null == startedAt
          ? _value.startedAt
          : startedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      endedAt: freezed == endedAt
          ? _value.endedAt
          : endedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      metricsSnapshot: freezed == metricsSnapshot
          ? _value.metricsSnapshot
          : metricsSnapshot // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PhoenixStateImplCopyWith<$Res>
    implements $PhoenixStateCopyWith<$Res> {
  factory _$$PhoenixStateImplCopyWith(
          _$PhoenixStateImpl value, $Res Function(_$PhoenixStateImpl) then) =
      __$$PhoenixStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      bool active,
      DateTime startedAt,
      DateTime? endedAt,
      Map<String, dynamic>? metricsSnapshot});
}

/// @nodoc
class __$$PhoenixStateImplCopyWithImpl<$Res>
    extends _$PhoenixStateCopyWithImpl<$Res, _$PhoenixStateImpl>
    implements _$$PhoenixStateImplCopyWith<$Res> {
  __$$PhoenixStateImplCopyWithImpl(
      _$PhoenixStateImpl _value, $Res Function(_$PhoenixStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of PhoenixState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? active = null,
    Object? startedAt = null,
    Object? endedAt = freezed,
    Object? metricsSnapshot = freezed,
  }) {
    return _then(_$PhoenixStateImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      startedAt: null == startedAt
          ? _value.startedAt
          : startedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      endedAt: freezed == endedAt
          ? _value.endedAt
          : endedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      metricsSnapshot: freezed == metricsSnapshot
          ? _value._metricsSnapshot
          : metricsSnapshot // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PhoenixStateImpl implements _PhoenixState {
  const _$PhoenixStateImpl(
      {required this.id,
      required this.userId,
      this.active = false,
      required this.startedAt,
      this.endedAt,
      final Map<String, dynamic>? metricsSnapshot})
      : _metricsSnapshot = metricsSnapshot;

  factory _$PhoenixStateImpl.fromJson(Map<String, dynamic> json) =>
      _$$PhoenixStateImplFromJson(json);

  @override
  final String id;
  @override
  final String userId;
  @override
  @JsonKey()
  final bool active;
  @override
  final DateTime startedAt;
  @override
  final DateTime? endedAt;
  final Map<String, dynamic>? _metricsSnapshot;
  @override
  Map<String, dynamic>? get metricsSnapshot {
    final value = _metricsSnapshot;
    if (value == null) return null;
    if (_metricsSnapshot is EqualUnmodifiableMapView) return _metricsSnapshot;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'PhoenixState(id: $id, userId: $userId, active: $active, startedAt: $startedAt, endedAt: $endedAt, metricsSnapshot: $metricsSnapshot)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PhoenixStateImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.active, active) || other.active == active) &&
            (identical(other.startedAt, startedAt) ||
                other.startedAt == startedAt) &&
            (identical(other.endedAt, endedAt) || other.endedAt == endedAt) &&
            const DeepCollectionEquality()
                .equals(other._metricsSnapshot, _metricsSnapshot));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, userId, active, startedAt,
      endedAt, const DeepCollectionEquality().hash(_metricsSnapshot));

  /// Create a copy of PhoenixState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PhoenixStateImplCopyWith<_$PhoenixStateImpl> get copyWith =>
      __$$PhoenixStateImplCopyWithImpl<_$PhoenixStateImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PhoenixStateImplToJson(
      this,
    );
  }
}

abstract class _PhoenixState implements PhoenixState {
  const factory _PhoenixState(
      {required final String id,
      required final String userId,
      final bool active,
      required final DateTime startedAt,
      final DateTime? endedAt,
      final Map<String, dynamic>? metricsSnapshot}) = _$PhoenixStateImpl;

  factory _PhoenixState.fromJson(Map<String, dynamic> json) =
      _$PhoenixStateImpl.fromJson;

  @override
  String get id;
  @override
  String get userId;
  @override
  bool get active;
  @override
  DateTime get startedAt;
  @override
  DateTime? get endedAt;
  @override
  Map<String, dynamic>? get metricsSnapshot;

  /// Create a copy of PhoenixState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PhoenixStateImplCopyWith<_$PhoenixStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
